#!/usr/bin/python3
#
# Smart Meter Logger Transport
# Reads mqtt power-log and sends it to Redis Server
# Copyright: Stefan Koch
# License: GPLv3
#

import paho.mqtt.client as mqtt
from   datetime import datetime
import json
import sys

sys.path.append("../rediscon")
from rediscon import RedisCon
from modules.configfile import ConfigFile

print("Smart Meter Redis Logger")

#
# Check for debug mode (use -d)
#
debug = False
if 2 == len(sys.argv):
    cmd_arg = sys.argv[1]
    if cmd_arg == "-d":
        debug = True

#
# open and parse configuration file
# see smlogger.conf-example for examples
#
try:
    conf            = ConfigFile("smlogger.conf")
    mqtt_topic      = conf.get_value("mqtt_topic")
    redis_server    = conf.get_value("redis_server")
    pow_current_key = conf.get_value("power_current_key")
    pow_day_key     = conf.get_value("power_day_key")
    update_period   = conf.get_value("update_period")
    avg_window_size = conf.get_value("avg_window_size")
except Exception as e:
    print(e)
    sys.exit(1)

#
# time functions to determine update time and daily usage report
#
def get_ts():
    return int(datetime.now().timestamp())


tzone = datetime.now().astimezone().tzinfo
def get_day_mark():
    return  "%02d%02d" % (datetime.now(tz=tzone).hour, datetime.now(tz=tzone).minute)


#
# print out important configuration parameters
#
print("-------------------------------")
print("redis_server    = " + str(redis_server))
print("pow_current_key = " + str(pow_current_key))
print("pow_day_key     = " + str(pow_day_key))
print("redis_server    = " + str(redis_server))
print("mqtt_topic      = " + str(mqtt_topic))
print("update_period   = " + str(update_period))
print("avg_window_size = " + str(avg_window_size))
print("debug           = " + str(debug))
print("-------------------------------")

#
# connect to Redis
# Redis is our outgoing data channel. The redis instance is mostly remote
# you can modify the value keys in the config file
#
print("connect Redis..")
try:
    red = RedisCon(name="powlog", host=redis_server, log_enabled=False, trx_log=debug)
    red.setConMonInterval(5)
    red.connect()
except Exception as e:
    print(e)
    sys.exit(1)
print("OK")

#
# these variables track the two different update moments
#
ts    = get_ts()
dmark = get_day_mark()

#
# windowing functions to smooth out the current power value
# if your processing/visualization backend does smooting as well then you
# should reduce the window size in the config file
#
val_window = [0] * avg_window_size
def window_insert(v):
    global val_window
    size = len(val_window)

    for i in range(0, size - 1):
        val_window[i] = val_window[i + 1]

    val_window[size - 1] = v


def window_avg():
    size = len(val_window)
    avg  = 0
    for i in range(0, size):
        avg += val_window[i]
    return int(avg / size)


#
# (part of mqtt callback)
# for every mqtt message this functionis executed
# here happens the averaging and time triggered updates to redis
#
def update(data):
    global ts
    global dmark
    p_cur = data['pmon']
    p_tot = data['ptot']

    window_insert(p_cur)
    cur_ts = get_ts()
    cur_dm = get_day_mark()

    if debug:
        print("ts=%d curdm=%s dm=%s ptot=%d pcur=%d" % 
            (cur_ts, cur_dm, dmark, p_tot, p_cur))

    if (cur_ts - ts) >= update_period:
        red.set(pow_current_key, window_avg())
        ts = cur_ts

    if (cur_dm != dmark) and (cur_dm == "2330"):
        red.set(pow_day_key, p_tot)
    dmark = cur_dm


#
# (mqtt callback)
# connection indicator, were we subscribe to the powlog mqtt topic
#
def mqtt_connect(client, userdata, flags, rc):
    print("OK " + str(rc))
    client.subscribe(mqtt_topic)

#
# (mqtt callback)
# called for every message on mqtt topic
# here we convert the json to python-dictionary
# any conversion error leads to ignore the message
#
def mqtt_message(client, userdata, msg):
    if (mqtt_topic == msg.topic):
        try:
            data = json.loads(msg.payload.decode("utf-8"))
        except:
            print("error json decode")
            print(str(msg.payload))
            return
        update(data)


print("connect MQTT..")
client = mqtt.Client()
client.on_connect = mqtt_connect
client.on_message = mqtt_message
client.connect("localhost", 1883, 60)
client.loop_forever()

# vim: set expandtab ts=4:
